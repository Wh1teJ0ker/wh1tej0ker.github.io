<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Wh1teJ0kerのBlog</title>
<meta charset=utf-8><meta name=description content='Ladder@2025阴间CTF
Misc
阴曹地府税务总局
大概思路就是基于做连接请求的时间戳前后大段时间进行爆破，验证成功率在一定比例以上就按照此时间戳去预测后续的股票波动率，获得flag


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189


from pwn import *
from random import Random
import time

context.log_level = &#39;info&#39;
logfile = open("record.log", "w", encoding="utf-8")

# ------------------- 基础功能 -------------------
def recv_and_record(io, delimiter, timeout=5):
    """接收服务器数据并同步记录到本地日志文件"""
    data = io.recvuntil(delimiter, timeout=timeout)  # 注意这里要调用 io.recvuntil，而不是自己！
    try:
        decoded = data.decode("utf-8", errors="ignore")
    except:
        decoded = str(data)
    logfile.write(decoded)
    logfile.flush()
    return decoded



def connect_to_server():
    """连接服务器"""
    return remote("nc1.ctfplus.cn", 29850)

def extract_tax_rates(raw_data):
    """提取历史税率"""
    lines = raw_data.splitlines()
    rates = []
    for line in lines:
        if "交易税率" in line and ":" in line:
            rate = int(line.split(":")[1].strip().replace("%", ""))
            rates.append(rate)
    return rates

def predict_seed_and_rates(history_rates, timestamp, time_window=120, skip_min=1, skip_max=20, tolerance=20):
    """爆破种子并预测未来税率"""
    best_score = 0
    best_result = None

    for ts in range(timestamp - time_window, timestamp + time_window + 1):
        for skip in range(skip_min, skip_max + 1):
            r = Random()
            r.seed(ts)
            for _ in range(skip):
                r.randint(0, 100)

            predicted = [r.randint(0, 100) for _ in range(10)]
            score = sum(abs(real - pred) <= tolerance for real, pred in zip(history_rates, predicted))

            if score > best_score:
                best_score = score
                best_result = (ts, skip, predicted)

    return best_result if best_result and best_score >= 6 else None

def should_burn(predicted_rate):
    """判断是否烧纸"""
    return predicted_rate <= 50  # 小于等于50才烧纸

def read_balance(io):
    """
    从服务器响应提取当前冥币余额，兼容各种情况。
    """
    try:
        resp = recv_and_record(io, [&#39;要进行烧纸交易吗？(y/n):&#39;, &#39;当前冥币:&#39;, &#39;当前冥币余额:&#39;], timeout=5)

    except EOFError:
        log.error("连接断开了，无法读取冥币余额！")
        return 0.0

    log.debug(f"收到服务器回应：{resp}")

    lines = resp.splitlines()
    balance = None

    # 遍历所有行，找可能的冥币余额
    for line in lines:
        if "当前冥币余额" in line or "当前冥币" in line:
            parts = line.split(":")
            if len(parts) >= 2:
                num_part = parts[1].strip()
                # 确保后面跟着数字
                if num_part:
                    try:
                        balance = float(num_part.split()[0])
                        break
                    except ValueError:
                        log.warning(f"冥币余额提取异常，内容：{num_part}")
  
    if balance is None:
        log.warning(f"找到了冥币字段但未提取到数字，默认返回0，原始内容：{resp}")
        return 0.0
    else:
        return balance




def burn_paper(io, predicted_rate, round_num):
    """执行烧纸操作，并返回真实税率"""
    io.sendline(&#39;y&#39;)
    recv_and_record(io, &#39;当前税率是(0-99%):&#39;)
    io.sendline(str(predicted_rate))

    resp = io.recvline().decode(errors=&#39;ignore&#39;)
    if "当前税率为" in resp:
        real_rate = int(resp.split(":")[1].strip().replace("%", ""))
        diff = abs(real_rate - predicted_rate)
        log.success(f"[第{round_num}轮] 烧纸！预测 {predicted_rate}% / 真实 {real_rate}% / 误差 {diff}%")
        return real_rate, diff
    else:
        log.warning(f"[第{round_num}轮] 未拿到真实税率！")
        return None, None

# ------------------- 主逻辑 -------------------

def attack():
    """执行完整攻击流程"""
    now = int(time.time())
    io = connect_to_server()

    # 第一次选n拿历史税率
    io.sendlineafter(&#39;(y/n):&#39;, &#39;n&#39;)
    data = recv_and_record(io,"税率参考数据已经给您了。")
    rates = extract_tax_rates(data)
    log.info(f"提取到历史税率：{rates}")

    # 预测种子
    result = predict_seed_and_rates(rates, now)
    if not result:
        log.error("种子爆破失败，退出")
        io.close()
        return

    seed, skip, predicted_list = result
    log.success(f"预测成功：种子={seed}，跳过轮数={skip}")
    log.info(f"预测未来税率（前10轮）：{predicted_list}")

    # 初始化新的伪随机器
    r = Random()
    r.seed(seed)
    for _ in range(skip + 10):
        r.randint(0, 100)

    coins = 0
    round_num = 1

    while coins < 10000:
        try:
            recv_and_record(io, &#39;要进行烧纸交易吗？(y/n):&#39;)
        except EOFError:
            io.interactive()
            log.warning("服务器关闭了连接，正常退出！")
            break
        predicted_rate = r.randint(0, 100)

        if should_burn(predicted_rate):
            real_rate, diff = burn_paper(io, predicted_rate, round_num)

            if real_rate is not None and diff > 20:
                log.warning(f"[第{round_num}轮] 预测偏差过大 (预测 {predicted_rate}%，真实 {real_rate}%)，但继续执行！")
        else:
            io.sendline(&#39;n&#39;)
            log.info(f"[第{round_num}轮] 预测税率 {predicted_rate}% ，跳过。")

        # 更新冥币余额
        coins = read_balance(io)
        if coins is None:
            log.error("余额读取失败。")
            break
        else:
            log.info(f"当前冥币余额：{coins}")

        round_num += 1
        if round_num > 100:
            log.warning("回合过多，自动退出保护。")
            break

    if coins and coins >= 10000:
        log.success(f"冥币余额达到 {coins}，准备拿 FLAG！")
        io.interactive()

    io.close()
    logfile.close()


if __name__ == "__main__":
    attack()


​​'><meta name=author content="Wh1teJ0ker"><link rel=canonical href=https://wh1tej0ker.github.io/post/2025-underworld-ctf-1atj9l.html><link rel=alternate type=application/rss+xml href=https://wh1tej0ker.github.io//index.xml title=Wh1teJ0kerのBlog><script async defer data-website-id=56cc42c1-3656-4d3e-af3c-acded927b8ed src=https://analytics.umami.is/script.js></script><meta property="og:url" content="https://wh1tej0ker.github.io/post/2025-underworld-ctf-1atj9l.html"><meta property="og:site_name" content="Wh1teJ0kerのBlog"><meta property="og:title" content="2025阴间CTF"><meta property="og:description" content='2025阴间CTF Misc 阴曹地府税务总局 大概思路就是基于做连接请求的时间戳前后大段时间进行爆破，验证成功率在一定比例以上就按照此时间戳去预测后续的股票波动率，获得flag
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 from pwn import * from random import Random import time context.log_level = &#39;info&#39; logfile = open("record.log", "w", encoding="utf-8") # ------------------- 基础功能 ------------------- def recv_and_record(io, delimiter, timeout=5): """接收服务器数据并同步记录到本地日志文件""" data = io.recvuntil(delimiter, timeout=timeout) # 注意这里要调用 io.recvuntil，而不是自己！ try: decoded = data.decode("utf-8", errors="ignore") except: decoded = str(data) logfile.write(decoded) logfile.flush() return decoded def connect_to_server(): """连接服务器""" return remote("nc1.ctfplus.cn", 29850) def extract_tax_rates(raw_data): """提取历史税率""" lines = raw_data.splitlines() rates = [] for line in lines: if "交易税率" in line and ":" in line: rate = int(line.split(":")[1].strip().replace("%", "")) rates.append(rate) return rates def predict_seed_and_rates(history_rates, timestamp, time_window=120, skip_min=1, skip_max=20, tolerance=20): """爆破种子并预测未来税率""" best_score = 0 best_result = None for ts in range(timestamp - time_window, timestamp + time_window + 1): for skip in range(skip_min, skip_max + 1): r = Random() r.seed(ts) for _ in range(skip): r.randint(0, 100) predicted = [r.randint(0, 100) for _ in range(10)] score = sum(abs(real - pred) <= tolerance for real, pred in zip(history_rates, predicted)) if score > best_score: best_score = score best_result = (ts, skip, predicted) return best_result if best_result and best_score >= 6 else None def should_burn(predicted_rate): """判断是否烧纸""" return predicted_rate <= 50 # 小于等于50才烧纸 def read_balance(io): """ 从服务器响应提取当前冥币余额，兼容各种情况。 """ try: resp = recv_and_record(io, [&#39;要进行烧纸交易吗？(y/n):&#39;, &#39;当前冥币:&#39;, &#39;当前冥币余额:&#39;], timeout=5) except EOFError: log.error("连接断开了，无法读取冥币余额！") return 0.0 log.debug(f"收到服务器回应：{resp}") lines = resp.splitlines() balance = None # 遍历所有行，找可能的冥币余额 for line in lines: if "当前冥币余额" in line or "当前冥币" in line: parts = line.split(":") if len(parts) >= 2: num_part = parts[1].strip() # 确保后面跟着数字 if num_part: try: balance = float(num_part.split()[0]) break except ValueError: log.warning(f"冥币余额提取异常，内容：{num_part}") if balance is None: log.warning(f"找到了冥币字段但未提取到数字，默认返回0，原始内容：{resp}") return 0.0 else: return balance def burn_paper(io, predicted_rate, round_num): """执行烧纸操作，并返回真实税率""" io.sendline(&#39;y&#39;) recv_and_record(io, &#39;当前税率是(0-99%):&#39;) io.sendline(str(predicted_rate)) resp = io.recvline().decode(errors=&#39;ignore&#39;) if "当前税率为" in resp: real_rate = int(resp.split(":")[1].strip().replace("%", "")) diff = abs(real_rate - predicted_rate) log.success(f"[第{round_num}轮] 烧纸！预测 {predicted_rate}% / 真实 {real_rate}% / 误差 {diff}%") return real_rate, diff else: log.warning(f"[第{round_num}轮] 未拿到真实税率！") return None, None # ------------------- 主逻辑 ------------------- def attack(): """执行完整攻击流程""" now = int(time.time()) io = connect_to_server() # 第一次选n拿历史税率 io.sendlineafter(&#39;(y/n):&#39;, &#39;n&#39;) data = recv_and_record(io,"税率参考数据已经给您了。") rates = extract_tax_rates(data) log.info(f"提取到历史税率：{rates}") # 预测种子 result = predict_seed_and_rates(rates, now) if not result: log.error("种子爆破失败，退出") io.close() return seed, skip, predicted_list = result log.success(f"预测成功：种子={seed}，跳过轮数={skip}") log.info(f"预测未来税率（前10轮）：{predicted_list}") # 初始化新的伪随机器 r = Random() r.seed(seed) for _ in range(skip + 10): r.randint(0, 100) coins = 0 round_num = 1 while coins < 10000: try: recv_and_record(io, &#39;要进行烧纸交易吗？(y/n):&#39;) except EOFError: io.interactive() log.warning("服务器关闭了连接，正常退出！") break predicted_rate = r.randint(0, 100) if should_burn(predicted_rate): real_rate, diff = burn_paper(io, predicted_rate, round_num) if real_rate is not None and diff > 20: log.warning(f"[第{round_num}轮] 预测偏差过大 (预测 {predicted_rate}%，真实 {real_rate}%)，但继续执行！") else: io.sendline(&#39;n&#39;) log.info(f"[第{round_num}轮] 预测税率 {predicted_rate}% ，跳过。") # 更新冥币余额 coins = read_balance(io) if coins is None: log.error("余额读取失败。") break else: log.info(f"当前冥币余额：{coins}") round_num += 1 if round_num > 100: log.warning("回合过多，自动退出保护。") break if coins and coins >= 10000: log.success(f"冥币余额达到 {coins}，准备拿 FLAG！") io.interactive() io.close() logfile.close() if __name__ == "__main__": attack() ​​'><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-04-05T00:16:03+08:00"><meta property="article:modified_time" content="2025-04-06T17:30:32+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="2025阴间CTF"><meta name=twitter:description content='2025阴间CTF Misc 阴曹地府税务总局 大概思路就是基于做连接请求的时间戳前后大段时间进行爆破，验证成功率在一定比例以上就按照此时间戳去预测后续的股票波动率，获得flag
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 from pwn import * from random import Random import time context.log_level = &#39;info&#39; logfile = open("record.log", "w", encoding="utf-8") # ------------------- 基础功能 ------------------- def recv_and_record(io, delimiter, timeout=5): """接收服务器数据并同步记录到本地日志文件""" data = io.recvuntil(delimiter, timeout=timeout) # 注意这里要调用 io.recvuntil，而不是自己！ try: decoded = data.decode("utf-8", errors="ignore") except: decoded = str(data) logfile.write(decoded) logfile.flush() return decoded def connect_to_server(): """连接服务器""" return remote("nc1.ctfplus.cn", 29850) def extract_tax_rates(raw_data): """提取历史税率""" lines = raw_data.splitlines() rates = [] for line in lines: if "交易税率" in line and ":" in line: rate = int(line.split(":")[1].strip().replace("%", "")) rates.append(rate) return rates def predict_seed_and_rates(history_rates, timestamp, time_window=120, skip_min=1, skip_max=20, tolerance=20): """爆破种子并预测未来税率""" best_score = 0 best_result = None for ts in range(timestamp - time_window, timestamp + time_window + 1): for skip in range(skip_min, skip_max + 1): r = Random() r.seed(ts) for _ in range(skip): r.randint(0, 100) predicted = [r.randint(0, 100) for _ in range(10)] score = sum(abs(real - pred) <= tolerance for real, pred in zip(history_rates, predicted)) if score > best_score: best_score = score best_result = (ts, skip, predicted) return best_result if best_result and best_score >= 6 else None def should_burn(predicted_rate): """判断是否烧纸""" return predicted_rate <= 50 # 小于等于50才烧纸 def read_balance(io): """ 从服务器响应提取当前冥币余额，兼容各种情况。 """ try: resp = recv_and_record(io, [&#39;要进行烧纸交易吗？(y/n):&#39;, &#39;当前冥币:&#39;, &#39;当前冥币余额:&#39;], timeout=5) except EOFError: log.error("连接断开了，无法读取冥币余额！") return 0.0 log.debug(f"收到服务器回应：{resp}") lines = resp.splitlines() balance = None # 遍历所有行，找可能的冥币余额 for line in lines: if "当前冥币余额" in line or "当前冥币" in line: parts = line.split(":") if len(parts) >= 2: num_part = parts[1].strip() # 确保后面跟着数字 if num_part: try: balance = float(num_part.split()[0]) break except ValueError: log.warning(f"冥币余额提取异常，内容：{num_part}") if balance is None: log.warning(f"找到了冥币字段但未提取到数字，默认返回0，原始内容：{resp}") return 0.0 else: return balance def burn_paper(io, predicted_rate, round_num): """执行烧纸操作，并返回真实税率""" io.sendline(&#39;y&#39;) recv_and_record(io, &#39;当前税率是(0-99%):&#39;) io.sendline(str(predicted_rate)) resp = io.recvline().decode(errors=&#39;ignore&#39;) if "当前税率为" in resp: real_rate = int(resp.split(":")[1].strip().replace("%", "")) diff = abs(real_rate - predicted_rate) log.success(f"[第{round_num}轮] 烧纸！预测 {predicted_rate}% / 真实 {real_rate}% / 误差 {diff}%") return real_rate, diff else: log.warning(f"[第{round_num}轮] 未拿到真实税率！") return None, None # ------------------- 主逻辑 ------------------- def attack(): """执行完整攻击流程""" now = int(time.time()) io = connect_to_server() # 第一次选n拿历史税率 io.sendlineafter(&#39;(y/n):&#39;, &#39;n&#39;) data = recv_and_record(io,"税率参考数据已经给您了。") rates = extract_tax_rates(data) log.info(f"提取到历史税率：{rates}") # 预测种子 result = predict_seed_and_rates(rates, now) if not result: log.error("种子爆破失败，退出") io.close() return seed, skip, predicted_list = result log.success(f"预测成功：种子={seed}，跳过轮数={skip}") log.info(f"预测未来税率（前10轮）：{predicted_list}") # 初始化新的伪随机器 r = Random() r.seed(seed) for _ in range(skip + 10): r.randint(0, 100) coins = 0 round_num = 1 while coins < 10000: try: recv_and_record(io, &#39;要进行烧纸交易吗？(y/n):&#39;) except EOFError: io.interactive() log.warning("服务器关闭了连接，正常退出！") break predicted_rate = r.randint(0, 100) if should_burn(predicted_rate): real_rate, diff = burn_paper(io, predicted_rate, round_num) if real_rate is not None and diff > 20: log.warning(f"[第{round_num}轮] 预测偏差过大 (预测 {predicted_rate}%，真实 {real_rate}%)，但继续执行！") else: io.sendline(&#39;n&#39;) log.info(f"[第{round_num}轮] 预测税率 {predicted_rate}% ，跳过。") # 更新冥币余额 coins = read_balance(io) if coins is None: log.error("余额读取失败。") break else: log.info(f"当前冥币余额：{coins}") round_num += 1 if round_num > 100: log.warning("回合过多，自动退出保护。") break if coins and coins >= 10000: log.success(f"冥币余额达到 {coins}，准备拿 FLAG！") io.interactive() io.close() logfile.close() if __name__ == "__main__": attack() ​​'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wh1tej0ker.github.io/post/"},{"@type":"ListItem","position":2,"name":"2025阴间CTF","item":"https://wh1tej0ker.github.io/post/2025-underworld-ctf-1atj9l.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2025阴间CTF","name":"2025阴间CTF","description":"2025阴间CTF Misc 阴曹地府税务总局 大概思路就是基于做连接请求的时间戳前后大段时间进行爆破，验证成功率在一定比例以上就按照此时间戳去预测后续的股票波动率，获得flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 from pwn import * from random import Random import time context.log_level = \u0026#39;info\u0026#39; logfile = open(\u0026#34;record.log\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) # ------------------- 基础功能 ------------------- def recv_and_record(io, delimiter, timeout=5): \u0026#34;\u0026#34;\u0026#34;接收服务器数据并同步记录到本地日志文件\u0026#34;\u0026#34;\u0026#34; data = io.recvuntil(delimiter, timeout=timeout) # 注意这里要调用 io.recvuntil，而不是自己！ try: decoded = data.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;ignore\u0026#34;) except: decoded = str(data) logfile.write(decoded) logfile.flush() return decoded def connect_to_server(): \u0026#34;\u0026#34;\u0026#34;连接服务器\u0026#34;\u0026#34;\u0026#34; return remote(\u0026#34;nc1.ctfplus.cn\u0026#34;, 29850) def extract_tax_rates(raw_data): \u0026#34;\u0026#34;\u0026#34;提取历史税率\u0026#34;\u0026#34;\u0026#34; lines = raw_data.splitlines() rates = [] for line in lines: if \u0026#34;交易税率\u0026#34; in line and \u0026#34;:\u0026#34; in line: rate = int(line.split(\u0026#34;:\u0026#34;)[1].strip().replace(\u0026#34;%\u0026#34;, \u0026#34;\u0026#34;)) rates.append(rate) return rates def predict_seed_and_rates(history_rates, timestamp, time_window=120, skip_min=1, skip_max=20, tolerance=20): \u0026#34;\u0026#34;\u0026#34;爆破种子并预测未来税率\u0026#34;\u0026#34;\u0026#34; best_score = 0 best_result = None for ts in range(timestamp - time_window, timestamp + time_window + 1): for skip in range(skip_min, skip_max + 1): r = Random() r.seed(ts) for _ in range(skip): r.randint(0, 100) predicted = [r.randint(0, 100) for _ in range(10)] score = sum(abs(real - pred) \u0026lt;= tolerance for real, pred in zip(history_rates, predicted)) if score \u0026gt; best_score: best_score = score best_result = (ts, skip, predicted) return best_result if best_result and best_score \u0026gt;= 6 else None def should_burn(predicted_rate): \u0026#34;\u0026#34;\u0026#34;判断是否烧纸\u0026#34;\u0026#34;\u0026#34; return predicted_rate \u0026lt;= 50 # 小于等于50才烧纸 def read_balance(io): \u0026#34;\u0026#34;\u0026#34; 从服务器响应提取当前冥币余额，兼容各种情况。 \u0026#34;\u0026#34;\u0026#34; try: resp = recv_and_record(io, [\u0026#39;要进行烧纸交易吗？(y/n):\u0026#39;, \u0026#39;当前冥币:\u0026#39;, \u0026#39;当前冥币余额:\u0026#39;], timeout=5) except EOFError: log.error(\u0026#34;连接断开了，无法读取冥币余额！\u0026#34;) return 0.0 log.debug(f\u0026#34;收到服务器回应：{resp}\u0026#34;) lines = resp.splitlines() balance = None # 遍历所有行，找可能的冥币余额 for line in lines: if \u0026#34;当前冥币余额\u0026#34; in line or \u0026#34;当前冥币\u0026#34; in line: parts = line.split(\u0026#34;:\u0026#34;) if len(parts) \u0026gt;= 2: num_part = parts[1].strip() # 确保后面跟着数字 if num_part: try: balance = float(num_part.split()[0]) break except ValueError: log.warning(f\u0026#34;冥币余额提取异常，内容：{num_part}\u0026#34;) if balance is None: log.warning(f\u0026#34;找到了冥币字段但未提取到数字，默认返回0，原始内容：{resp}\u0026#34;) return 0.0 else: return balance def burn_paper(io, predicted_rate, round_num): \u0026#34;\u0026#34;\u0026#34;执行烧纸操作，并返回真实税率\u0026#34;\u0026#34;\u0026#34; io.sendline(\u0026#39;y\u0026#39;) recv_and_record(io, \u0026#39;当前税率是(0-99%):\u0026#39;) io.sendline(str(predicted_rate)) resp = io.recvline().decode(errors=\u0026#39;ignore\u0026#39;) if \u0026#34;当前税率为\u0026#34; in resp: real_rate = int(resp.split(\u0026#34;:\u0026#34;)[1].strip().replace(\u0026#34;%\u0026#34;, \u0026#34;\u0026#34;)) diff = abs(real_rate - predicted_rate) log.success(f\u0026#34;[第{round_num}轮] 烧纸！预测 {predicted_rate}% / 真实 {real_rate}% / 误差 {diff}%\u0026#34;) return real_rate, diff else: log.warning(f\u0026#34;[第{round_num}轮] 未拿到真实税率！\u0026#34;) return None, None # ------------------- 主逻辑 ------------------- def attack(): \u0026#34;\u0026#34;\u0026#34;执行完整攻击流程\u0026#34;\u0026#34;\u0026#34; now = int(time.time()) io = connect_to_server() # 第一次选n拿历史税率 io.sendlineafter(\u0026#39;(y/n):\u0026#39;, \u0026#39;n\u0026#39;) data = recv_and_record(io,\u0026#34;税率参考数据已经给您了。\u0026#34;) rates = extract_tax_rates(data) log.info(f\u0026#34;提取到历史税率：{rates}\u0026#34;) # 预测种子 result = predict_seed_and_rates(rates, now) if not result: log.error(\u0026#34;种子爆破失败，退出\u0026#34;) io.close() return seed, skip, predicted_list = result log.success(f\u0026#34;预测成功：种子={seed}，跳过轮数={skip}\u0026#34;) log.info(f\u0026#34;预测未来税率（前10轮）：{predicted_list}\u0026#34;) # 初始化新的伪随机器 r = Random() r.seed(seed) for _ in range(skip + 10): r.randint(0, 100) coins = 0 round_num = 1 while coins \u0026lt; 10000: try: recv_and_record(io, \u0026#39;要进行烧纸交易吗？(y/n):\u0026#39;) except EOFError: io.interactive() log.warning(\u0026#34;服务器关闭了连接，正常退出！\u0026#34;) break predicted_rate = r.randint(0, 100) if should_burn(predicted_rate): real_rate, diff = burn_paper(io, predicted_rate, round_num) if real_rate is not None and diff \u0026gt; 20: log.warning(f\u0026#34;[第{round_num}轮] 预测偏差过大 (预测 {predicted_rate}%，真实 {real_rate}%)，但继续执行！\u0026#34;) else: io.sendline(\u0026#39;n\u0026#39;) log.info(f\u0026#34;[第{round_num}轮] 预测税率 {predicted_rate}% ，跳过。\u0026#34;) # 更新冥币余额 coins = read_balance(io) if coins is None: log.error(\u0026#34;余额读取失败。\u0026#34;) break else: log.info(f\u0026#34;当前冥币余额：{coins}\u0026#34;) round_num += 1 if round_num \u0026gt; 100: log.warning(\u0026#34;回合过多，自动退出保护。\u0026#34;) break if coins and coins \u0026gt;= 10000: log.success(f\u0026#34;冥币余额达到 {coins}，准备拿 FLAG！\u0026#34;) io.interactive() io.close() logfile.close() if __name__ == \u0026#34;__main__\u0026#34;: attack() ​​\n","keywords":[],"articleBody":"2025阴间CTF Misc 阴曹地府税务总局 大概思路就是基于做连接请求的时间戳前后大段时间进行爆破，验证成功率在一定比例以上就按照此时间戳去预测后续的股票波动率，获得flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 from pwn import * from random import Random import time context.log_level = 'info' logfile = open(\"record.log\", \"w\", encoding=\"utf-8\") # ------------------- 基础功能 ------------------- def recv_and_record(io, delimiter, timeout=5): \"\"\"接收服务器数据并同步记录到本地日志文件\"\"\" data = io.recvuntil(delimiter, timeout=timeout) # 注意这里要调用 io.recvuntil，而不是自己！ try: decoded = data.decode(\"utf-8\", errors=\"ignore\") except: decoded = str(data) logfile.write(decoded) logfile.flush() return decoded def connect_to_server(): \"\"\"连接服务器\"\"\" return remote(\"nc1.ctfplus.cn\", 29850) def extract_tax_rates(raw_data): \"\"\"提取历史税率\"\"\" lines = raw_data.splitlines() rates = [] for line in lines: if \"交易税率\" in line and \":\" in line: rate = int(line.split(\":\")[1].strip().replace(\"%\", \"\")) rates.append(rate) return rates def predict_seed_and_rates(history_rates, timestamp, time_window=120, skip_min=1, skip_max=20, tolerance=20): \"\"\"爆破种子并预测未来税率\"\"\" best_score = 0 best_result = None for ts in range(timestamp - time_window, timestamp + time_window + 1): for skip in range(skip_min, skip_max + 1): r = Random() r.seed(ts) for _ in range(skip): r.randint(0, 100) predicted = [r.randint(0, 100) for _ in range(10)] score = sum(abs(real - pred) \u003c= tolerance for real, pred in zip(history_rates, predicted)) if score \u003e best_score: best_score = score best_result = (ts, skip, predicted) return best_result if best_result and best_score \u003e= 6 else None def should_burn(predicted_rate): \"\"\"判断是否烧纸\"\"\" return predicted_rate \u003c= 50 # 小于等于50才烧纸 def read_balance(io): \"\"\" 从服务器响应提取当前冥币余额，兼容各种情况。 \"\"\" try: resp = recv_and_record(io, ['要进行烧纸交易吗？(y/n):', '当前冥币:', '当前冥币余额:'], timeout=5) except EOFError: log.error(\"连接断开了，无法读取冥币余额！\") return 0.0 log.debug(f\"收到服务器回应：{resp}\") lines = resp.splitlines() balance = None # 遍历所有行，找可能的冥币余额 for line in lines: if \"当前冥币余额\" in line or \"当前冥币\" in line: parts = line.split(\":\") if len(parts) \u003e= 2: num_part = parts[1].strip() # 确保后面跟着数字 if num_part: try: balance = float(num_part.split()[0]) break except ValueError: log.warning(f\"冥币余额提取异常，内容：{num_part}\") if balance is None: log.warning(f\"找到了冥币字段但未提取到数字，默认返回0，原始内容：{resp}\") return 0.0 else: return balance def burn_paper(io, predicted_rate, round_num): \"\"\"执行烧纸操作，并返回真实税率\"\"\" io.sendline('y') recv_and_record(io, '当前税率是(0-99%):') io.sendline(str(predicted_rate)) resp = io.recvline().decode(errors='ignore') if \"当前税率为\" in resp: real_rate = int(resp.split(\":\")[1].strip().replace(\"%\", \"\")) diff = abs(real_rate - predicted_rate) log.success(f\"[第{round_num}轮] 烧纸！预测 {predicted_rate}% / 真实 {real_rate}% / 误差 {diff}%\") return real_rate, diff else: log.warning(f\"[第{round_num}轮] 未拿到真实税率！\") return None, None # ------------------- 主逻辑 ------------------- def attack(): \"\"\"执行完整攻击流程\"\"\" now = int(time.time()) io = connect_to_server() # 第一次选n拿历史税率 io.sendlineafter('(y/n):', 'n') data = recv_and_record(io,\"税率参考数据已经给您了。\") rates = extract_tax_rates(data) log.info(f\"提取到历史税率：{rates}\") # 预测种子 result = predict_seed_and_rates(rates, now) if not result: log.error(\"种子爆破失败，退出\") io.close() return seed, skip, predicted_list = result log.success(f\"预测成功：种子={seed}，跳过轮数={skip}\") log.info(f\"预测未来税率（前10轮）：{predicted_list}\") # 初始化新的伪随机器 r = Random() r.seed(seed) for _ in range(skip + 10): r.randint(0, 100) coins = 0 round_num = 1 while coins \u003c 10000: try: recv_and_record(io, '要进行烧纸交易吗？(y/n):') except EOFError: io.interactive() log.warning(\"服务器关闭了连接，正常退出！\") break predicted_rate = r.randint(0, 100) if should_burn(predicted_rate): real_rate, diff = burn_paper(io, predicted_rate, round_num) if real_rate is not None and diff \u003e 20: log.warning(f\"[第{round_num}轮] 预测偏差过大 (预测 {predicted_rate}%，真实 {real_rate}%)，但继续执行！\") else: io.sendline('n') log.info(f\"[第{round_num}轮] 预测税率 {predicted_rate}% ，跳过。\") # 更新冥币余额 coins = read_balance(io) if coins is None: log.error(\"余额读取失败。\") break else: log.info(f\"当前冥币余额：{coins}\") round_num += 1 if round_num \u003e 100: log.warning(\"回合过多，自动退出保护。\") break if coins and coins \u003e= 10000: log.success(f\"冥币余额达到 {coins}，准备拿 FLAG！\") io.interactive() io.close() logfile.close() if __name__ == \"__main__\": attack() ​​\n拼尽全力没有对的上web的脑洞，唉，太阴了\n","wordCount":"2021","inLanguage":"en","datePublished":"2025-04-05T00:16:03+08:00","dateModified":"2025-04-06T17:30:32+08:00","author":{"@type":"Person","name":"Wh1teJ0ker"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wh1tej0ker.github.io/post/2025-underworld-ctf-1atj9l.html"},"publisher":{"@type":"Organization","name":"Wh1teJ0kerのBlog","logo":{"@type":"ImageObject","url":"https://wh1tej0ker.github.io/favicon.ico"}}}</script><link rel=icon type=image/png href=/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/favicon.ico><link rel=manifest href=/favicon.ico><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.9d998bab4720091d5ec1e0fbbffd92b254a2e791623df6106cd7ea760bfc5c28.css integrity="sha256-nZmLq0cgCR1eweD7v/2SslSi55FiPfYQbNfqdgv8XCg=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/categories/>分类</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives/>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/friends/>友链</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/about/>关于</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=https://cloud.umami.is/share/5RZUCwaG2fOysYPa/wh1tej0ker.github.io>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/Wh1teJ0ker><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>2025阴间CTF</h1></header><p><small>April 5, 2025&nbsp;· &nbsp;·</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#阴曹地府税务总局>阴曹地府税务总局</a></li></ul></nav></div><section class=blog-content><h1 id=2025阴间ctf>2025阴间CTF</h1><h1 id=misc>Misc</h1><h2 id=阴曹地府税务总局>阴曹地府税务总局</h2><p>大概思路就是基于做连接请求的时间戳前后大段时间进行爆破，验证成功率在一定比例以上就按照此时间戳去预测后续的股票波动率，获得flag</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>from pwn import *
</span></span><span class=line><span class=cl>from random import Random
</span></span><span class=line><span class=cl>import <span class=nb>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>context.log_level <span class=o>=</span> <span class=s1>&#39;info&#39;</span>
</span></span><span class=line><span class=cl><span class=nv>logfile</span> <span class=o>=</span> open<span class=o>(</span><span class=s2>&#34;record.log&#34;</span>, <span class=s2>&#34;w&#34;</span>, <span class=nv>encoding</span><span class=o>=</span><span class=s2>&#34;utf-8&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ------------------- 基础功能 -------------------</span>
</span></span><span class=line><span class=cl>def recv_and_record<span class=o>(</span>io, delimiter, <span class=nv>timeout</span><span class=o>=</span>5<span class=o>)</span>:
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;接收服务器数据并同步记录到本地日志文件&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>data</span> <span class=o>=</span> io.recvuntil<span class=o>(</span>delimiter, <span class=nv>timeout</span><span class=o>=</span>timeout<span class=o>)</span>  <span class=c1># 注意这里要调用 io.recvuntil，而不是自己！</span>
</span></span><span class=line><span class=cl>    try:
</span></span><span class=line><span class=cl>        <span class=nv>decoded</span> <span class=o>=</span> data.decode<span class=o>(</span><span class=s2>&#34;utf-8&#34;</span>, <span class=nv>errors</span><span class=o>=</span><span class=s2>&#34;ignore&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    except:
</span></span><span class=line><span class=cl>        <span class=nv>decoded</span> <span class=o>=</span> str<span class=o>(</span>data<span class=o>)</span>
</span></span><span class=line><span class=cl>    logfile.write<span class=o>(</span>decoded<span class=o>)</span>
</span></span><span class=line><span class=cl>    logfile.flush<span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> decoded
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def connect_to_server<span class=o>()</span>:
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;连接服务器&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> remote<span class=o>(</span><span class=s2>&#34;nc1.ctfplus.cn&#34;</span>, 29850<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def extract_tax_rates<span class=o>(</span>raw_data<span class=o>)</span>:
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;提取历史税率&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>lines</span> <span class=o>=</span> raw_data.splitlines<span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=nv>rates</span> <span class=o>=</span> <span class=o>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> line in lines:
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=s2>&#34;交易税率&#34;</span> in line and <span class=s2>&#34;:&#34;</span> in line:
</span></span><span class=line><span class=cl>            <span class=nv>rate</span> <span class=o>=</span> int<span class=o>(</span>line.split<span class=o>(</span><span class=s2>&#34;:&#34;</span><span class=o>)[</span>1<span class=o>]</span>.strip<span class=o>()</span>.replace<span class=o>(</span><span class=s2>&#34;%&#34;</span>, <span class=s2>&#34;&#34;</span><span class=o>))</span>
</span></span><span class=line><span class=cl>            rates.append<span class=o>(</span>rate<span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> rates
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def predict_seed_and_rates<span class=o>(</span>history_rates, timestamp, <span class=nv>time_window</span><span class=o>=</span>120, <span class=nv>skip_min</span><span class=o>=</span>1, <span class=nv>skip_max</span><span class=o>=</span>20, <span class=nv>tolerance</span><span class=o>=</span>20<span class=o>)</span>:
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;爆破种子并预测未来税率&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>best_score</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=nv>best_result</span> <span class=o>=</span> None
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> ts in range<span class=o>(</span>timestamp - time_window, timestamp + time_window + 1<span class=o>)</span>:
</span></span><span class=line><span class=cl>        <span class=k>for</span> skip in range<span class=o>(</span>skip_min, skip_max + 1<span class=o>)</span>:
</span></span><span class=line><span class=cl>            <span class=nv>r</span> <span class=o>=</span> Random<span class=o>()</span>
</span></span><span class=line><span class=cl>            r.seed<span class=o>(</span>ts<span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> _ in range<span class=o>(</span>skip<span class=o>)</span>:
</span></span><span class=line><span class=cl>                r.randint<span class=o>(</span>0, 100<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nv>predicted</span> <span class=o>=</span> <span class=o>[</span>r.randint<span class=o>(</span>0, 100<span class=o>)</span> <span class=k>for</span> _ in range<span class=o>(</span>10<span class=o>)]</span>
</span></span><span class=line><span class=cl>            <span class=nv>score</span> <span class=o>=</span> sum<span class=o>(</span>abs<span class=o>(</span>real - pred<span class=o>)</span> &lt;<span class=o>=</span> tolerance <span class=k>for</span> real, pred in zip<span class=o>(</span>history_rates, predicted<span class=o>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> score &gt; best_score:
</span></span><span class=line><span class=cl>                <span class=nv>best_score</span> <span class=o>=</span> score
</span></span><span class=line><span class=cl>                <span class=nv>best_result</span> <span class=o>=</span> <span class=o>(</span>ts, skip, predicted<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> best_result <span class=k>if</span> best_result and best_score &gt;<span class=o>=</span> <span class=m>6</span> <span class=k>else</span> None
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def should_burn<span class=o>(</span>predicted_rate<span class=o>)</span>:
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;判断是否烧纸&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> predicted_rate &lt;<span class=o>=</span> <span class=m>50</span>  <span class=c1># 小于等于50才烧纸</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def read_balance<span class=o>(</span>io<span class=o>)</span>:
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    从服务器响应提取当前冥币余额，兼容各种情况。
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    try:
</span></span><span class=line><span class=cl>        <span class=nv>resp</span> <span class=o>=</span> recv_and_record<span class=o>(</span>io, <span class=o>[</span><span class=s1>&#39;要进行烧纸交易吗？(y/n):&#39;</span>, <span class=s1>&#39;当前冥币:&#39;</span>, <span class=s1>&#39;当前冥币余额:&#39;</span><span class=o>]</span>, <span class=nv>timeout</span><span class=o>=</span>5<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    except EOFError:
</span></span><span class=line><span class=cl>        log.error<span class=o>(</span><span class=s2>&#34;连接断开了，无法读取冥币余额！&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> 0.0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    log.debug<span class=o>(</span>f<span class=s2>&#34;收到服务器回应：{resp}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nv>lines</span> <span class=o>=</span> resp.splitlines<span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=nv>balance</span> <span class=o>=</span> None
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 遍历所有行，找可能的冥币余额</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> line in lines:
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=s2>&#34;当前冥币余额&#34;</span> in line or <span class=s2>&#34;当前冥币&#34;</span> in line:
</span></span><span class=line><span class=cl>            <span class=nv>parts</span> <span class=o>=</span> line.split<span class=o>(</span><span class=s2>&#34;:&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> len<span class=o>(</span>parts<span class=o>)</span> &gt;<span class=o>=</span> 2:
</span></span><span class=line><span class=cl>                <span class=nv>num_part</span> <span class=o>=</span> parts<span class=o>[</span>1<span class=o>]</span>.strip<span class=o>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># 确保后面跟着数字</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> num_part:
</span></span><span class=line><span class=cl>                    try:
</span></span><span class=line><span class=cl>                        <span class=nv>balance</span> <span class=o>=</span> float<span class=o>(</span>num_part.split<span class=o>()[</span>0<span class=o>])</span>
</span></span><span class=line><span class=cl>                        <span class=nb>break</span>
</span></span><span class=line><span class=cl>                    except ValueError:
</span></span><span class=line><span class=cl>                        log.warning<span class=o>(</span>f<span class=s2>&#34;冥币余额提取异常，内容：{num_part}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>if</span> balance is None:
</span></span><span class=line><span class=cl>        log.warning<span class=o>(</span>f<span class=s2>&#34;找到了冥币字段但未提取到数字，默认返回0，原始内容：{resp}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> 0.0
</span></span><span class=line><span class=cl>    <span class=k>else</span>:
</span></span><span class=line><span class=cl>        <span class=k>return</span> balance
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def burn_paper<span class=o>(</span>io, predicted_rate, round_num<span class=o>)</span>:
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;执行烧纸操作，并返回真实税率&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    io.sendline<span class=o>(</span><span class=s1>&#39;y&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    recv_and_record<span class=o>(</span>io, <span class=s1>&#39;当前税率是(0-99%):&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    io.sendline<span class=o>(</span>str<span class=o>(</span>predicted_rate<span class=o>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nv>resp</span> <span class=o>=</span> io.recvline<span class=o>()</span>.decode<span class=o>(</span><span class=nv>errors</span><span class=o>=</span><span class=s1>&#39;ignore&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s2>&#34;当前税率为&#34;</span> in resp:
</span></span><span class=line><span class=cl>        <span class=nv>real_rate</span> <span class=o>=</span> int<span class=o>(</span>resp.split<span class=o>(</span><span class=s2>&#34;:&#34;</span><span class=o>)[</span>1<span class=o>]</span>.strip<span class=o>()</span>.replace<span class=o>(</span><span class=s2>&#34;%&#34;</span>, <span class=s2>&#34;&#34;</span><span class=o>))</span>
</span></span><span class=line><span class=cl>        <span class=nv>diff</span> <span class=o>=</span> abs<span class=o>(</span>real_rate - predicted_rate<span class=o>)</span>
</span></span><span class=line><span class=cl>        log.success<span class=o>(</span>f<span class=s2>&#34;[第{round_num}轮] 烧纸！预测 {predicted_rate}% / 真实 {real_rate}% / 误差 {diff}%&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> real_rate, diff
</span></span><span class=line><span class=cl>    <span class=k>else</span>:
</span></span><span class=line><span class=cl>        log.warning<span class=o>(</span>f<span class=s2>&#34;[第{round_num}轮] 未拿到真实税率！&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> None, None
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ------------------- 主逻辑 -------------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def attack<span class=o>()</span>:
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;执行完整攻击流程&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>now</span> <span class=o>=</span> int<span class=o>(</span>time.time<span class=o>())</span>
</span></span><span class=line><span class=cl>    <span class=nv>io</span> <span class=o>=</span> connect_to_server<span class=o>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 第一次选n拿历史税率</span>
</span></span><span class=line><span class=cl>    io.sendlineafter<span class=o>(</span><span class=s1>&#39;(y/n):&#39;</span>, <span class=s1>&#39;n&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=nv>data</span> <span class=o>=</span> recv_and_record<span class=o>(</span>io,<span class=s2>&#34;税率参考数据已经给您了。&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=nv>rates</span> <span class=o>=</span> extract_tax_rates<span class=o>(</span>data<span class=o>)</span>
</span></span><span class=line><span class=cl>    log.info<span class=o>(</span>f<span class=s2>&#34;提取到历史税率：{rates}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 预测种子</span>
</span></span><span class=line><span class=cl>    <span class=nv>result</span> <span class=o>=</span> predict_seed_and_rates<span class=o>(</span>rates, now<span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> not result:
</span></span><span class=line><span class=cl>        log.error<span class=o>(</span><span class=s2>&#34;种子爆破失败，退出&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        io.close<span class=o>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    seed, skip, <span class=nv>predicted_list</span> <span class=o>=</span> result
</span></span><span class=line><span class=cl>    log.success<span class=o>(</span>f<span class=s2>&#34;预测成功：种子={seed}，跳过轮数={skip}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    log.info<span class=o>(</span>f<span class=s2>&#34;预测未来税率（前10轮）：{predicted_list}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 初始化新的伪随机器</span>
</span></span><span class=line><span class=cl>    <span class=nv>r</span> <span class=o>=</span> Random<span class=o>()</span>
</span></span><span class=line><span class=cl>    r.seed<span class=o>(</span>seed<span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> _ in range<span class=o>(</span>skip + 10<span class=o>)</span>:
</span></span><span class=line><span class=cl>        r.randint<span class=o>(</span>0, 100<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nv>coins</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=nv>round_num</span> <span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> coins &lt; 10000:
</span></span><span class=line><span class=cl>        try:
</span></span><span class=line><span class=cl>            recv_and_record<span class=o>(</span>io, <span class=s1>&#39;要进行烧纸交易吗？(y/n):&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        except EOFError:
</span></span><span class=line><span class=cl>            io.interactive<span class=o>()</span>
</span></span><span class=line><span class=cl>            log.warning<span class=o>(</span><span class=s2>&#34;服务器关闭了连接，正常退出！&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>break</span>
</span></span><span class=line><span class=cl>        <span class=nv>predicted_rate</span> <span class=o>=</span> r.randint<span class=o>(</span>0, 100<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> should_burn<span class=o>(</span>predicted_rate<span class=o>)</span>:
</span></span><span class=line><span class=cl>            real_rate, <span class=nv>diff</span> <span class=o>=</span> burn_paper<span class=o>(</span>io, predicted_rate, round_num<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> real_rate is not None and diff &gt; 20:
</span></span><span class=line><span class=cl>                log.warning<span class=o>(</span>f<span class=s2>&#34;[第{round_num}轮] 预测偏差过大 (预测 {predicted_rate}%，真实 {real_rate}%)，但继续执行！&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>:
</span></span><span class=line><span class=cl>            io.sendline<span class=o>(</span><span class=s1>&#39;n&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            log.info<span class=o>(</span>f<span class=s2>&#34;[第{round_num}轮] 预测税率 {predicted_rate}% ，跳过。&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 更新冥币余额</span>
</span></span><span class=line><span class=cl>        <span class=nv>coins</span> <span class=o>=</span> read_balance<span class=o>(</span>io<span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> coins is None:
</span></span><span class=line><span class=cl>            log.error<span class=o>(</span><span class=s2>&#34;余额读取失败。&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>break</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>:
</span></span><span class=line><span class=cl>            log.info<span class=o>(</span>f<span class=s2>&#34;当前冥币余额：{coins}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nv>round_num</span> <span class=o>+=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> round_num &gt; 100:
</span></span><span class=line><span class=cl>            log.warning<span class=o>(</span><span class=s2>&#34;回合过多，自动退出保护。&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> coins and coins &gt;<span class=o>=</span> 10000:
</span></span><span class=line><span class=cl>        log.success<span class=o>(</span>f<span class=s2>&#34;冥币余额达到 {coins}，准备拿 FLAG！&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        io.interactive<span class=o>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    io.close<span class=o>()</span>
</span></span><span class=line><span class=cl>    logfile.close<span class=o>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nv>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span>:
</span></span><span class=line><span class=cl>    attack<span class=o>()</span>
</span></span></code></pre></td></tr></table></div></div><p>​<img src=https://raw.githubusercontent.com/Wh1teJ0ker/PicGo/main/Pic/QQ_1743783416158-20250405001657-9okbvy4.png alt=QQ_1743783416158>​</p><p>拼尽全力没有对的上web的脑洞，唉，太阴了</p></section><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","Wh1teJ0ker/discussion"),s.setAttribute("data-repo-id","R_kgDOOTzcZA"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOOTzcZM4CoxXV"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","zh-CN"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div><div class=paginator><a class=next href=https://wh1tej0ker.github.io/post/2024-pengcheng-cup-1osmmv.html><span>2024鹏程杯</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2025 <a href=https://wh1tej0ker.github.io/>Wh1teJ0kerのBlog</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=/main.min.cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e.js integrity="sha512-z4PhNX7vuL3xVChQ1m2AB9Yg5AULVxXcg/SpIdNs6c5H0NE8XYXysP+DGNKHfuwvY7kxvUdBeoGlODJ6+SfaPg==" crossorigin=anonymous defer></script></html>